package unitins;

import java.util.ArrayList;

public class Graph {
    private List<Node> nodes;

    public Graph() {
        this.nodes = new ArrayList<>();
    }

    public void addNode(Node node) {
        this.nodes.add(node);
    }

    public void addEdge(Node source, Node target) {
        source.addEdge(new Edge(target));
    }

    public List<Node> getNodes() {
        return this.nodes;
    }

    public void displayEdgesFromNode(Node node) {
        if (node.getEdges().isEmpty()) {
            System.out.println("O nó " + node + " não possui arestas.");
            return;
        }

        for (Edge edge : node.getEdges()) {
            System.out.println(node + edge.toString());
        }
    }

    public void printAllPaths(Node source, Node target) {
        boolean[] visited = new boolean[nodes.size()];
        List<Node> path = new ArrayList<>();

        // Marcar o nó atual como visitado e adicionar ao caminho
        visited[nodes.indexOf(source)] = true;
        path.add(source);

        printAllPathsUtil(source, target, visited, path);

        // Remover o nó atual e marcar como não visitado
        path.remove(source);
        visited[nodes.indexOf(source)] = false;
    }

    private void printAllPathsUtil(Node source, Node target, boolean[] visited, List<Node> path) {
        if (source.equals(target)) {
            System.out.println(path);
            return;
        }

        for (Edge edge : source.getEdges()) {
            Node adjNode = edge.getTarget();
            if (!visited[nodes.indexOf(adjNode)]) {
                // Marcar o nó adjacente como visitado e adicioná-lo ao caminho
                visited[nodes.indexOf(adjNode)] = true;
                path.add(adjNode);

                printAllPathsUtil(adjNode, target, visited, path);

                // Remover o nó adjacente do caminho e marcar como não visitado
                path.remove(adjNode);
                visited[nodes.indexOf(adjNode)] = false;
            }
        }
    }
}

}
